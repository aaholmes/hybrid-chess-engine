Design Document: SPRT-Based Match Manager1. Conceptual OverviewThe system will run a series of games between two UCI-compliant engines. After each game, it updates the Log-Likelihood Ratio (LLR). The match continues until the LLR hits either an upper bound (H1: New engine is stronger) or a lower bound (H0: New engine is not stronger).2. Mathematical FoundationThe SPRT logic must account for the draw ratio, as ignoring draws in chess leads to massive Elo estimation errors.Hypotheses:$H_0$: The Elo difference is $\text{elo}_0$ (usually 0).$H_1$: The Elo difference is $\text{elo}_1$ (e.g., 5 Elo).Likelihood Ratio (LR): The ratio of the probability of the results under $H_1$ vs. $H_0$.Decision Bounds:$A = \ln\left(\frac{\beta}{1 - \alpha}\right)$ (Lower bound to accept $H_0$)$B = \ln\left(\frac{1 - \beta}{\alpha}\right)$ (Upper bound to accept $H_1$)Where $\alpha$ is the false positive rate and $\beta$ is the false negative rate (commonly 0.05).3. Architecture Component DiagramEngine Controller: Manages UCI process lifecycle (stdin/stdout), move parsing, and time management.Match Orchestrator: Handles the game loop, opening book selection (PGN/EPD), and seat swapping (playing both sides of an opening to reduce bias).Stats Engine: The core "SPRT Calculator" that receives game results $(W, D, L)$ and evaluates the stop condition.Concurrency Manager: Uses a thread pool to run multiple games in parallel, feeding results back to a central stats collector via an asynchronous channel.4. Technical Specifications (Rust-Specific)Data StructuresMatchState: A thread-safe struct (using Arc<Mutex<...>> or AtomicUsize) to track wins, losses, and draws.SprtConfig: Contains the bounds $(\text{elo}_0, \text{elo}_1)$ and error probabilities $(\alpha, \beta)$.Statistical ModelYou should implement the Trinomial Logistic Model.Convert Elo bounds to expected scores ($P$) using the standard logistic formula: $P = \frac{1}{1 + 10^{-\Delta\text{Elo}/400}}$.Calculate the variance of the sample: $\sigma^2 = \text{score}_{avg} - (\text{score}_{avg})^2$.Correction: In chess, you must use the variance that accounts for draws: $\sigma^2 = \frac{W + \frac{D}{4}}{N} - (\frac{W + \frac{D}{2}}{N})^2$.Compute LLR using the formula:$$LLR = \frac{(\text{score}_1 - \text{score}_0) \cdot (2 \cdot \text{total\_score} - (\text{score}_0 + \text{score}_1))}{2 \cdot \text{variance}}$$Concurrency ModelUse Tokio or crossbeam for the task orchestration.The Orchestrator should spawn $N$ worker threads (where $N$ is your CPU count).Each worker requests a "Game Task" (Opening + Engine Pair), executes the match, and sends a ResultPacket back to the main thread.The main thread updates the LLR and broadcasts a "Shutdown" signal to workers if a bound is hit.5. Implementation RequirementsOpening Book Support: Implement a reader for .epd or .pgn files to ensure engines aren't just playing the same "Starting Position" (which leads to repetitive draws).Score Weighting: Explicitly map results to float values: Win = 1.0, Draw = 0.5, Loss = 0.0.Rounding/Precision: Use f64 for all LLR calculations to avoid accumulation errors over thousands of games.6. Expected WorkflowInit: Load EngineA and EngineB, set elo0=0, elo1=10.Iterate:Worker A plays Game 1 (A=White).Worker B plays Game 2 (B=White) on the same opening.Update: Add results to the global counter.Test:If $LLR > B$: Accept $H_1$ (New engine is definitely better).If $LLR < A$: Accept $H_0$ (Insignificant improvement).Output: Report final Elo difference and 95% confidence interval.
